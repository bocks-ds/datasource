const fs = require('fs')
const glob = require('glob')
const path = require('path');

const env = require('env_vars')

const typeMap = {'string': 'String', 'number': 'Int'}


function export_json_data() {
    env.logger.setDebugLevels("json parser")
    env.logger.info("Reading JSON into memory...")
    data = read_json_dir()
    table_names = Object.keys(data)
    table_structures = {}

    table_names.forEach((table_name, _) => {
        structure = get_table_structure(data[table_name], table_name)
        table_structures[table_name] = structure
    })
    exports.table_names = Object.keys(table_structures)
    exports.table_structures = table_structures
    exports.data = data
    env.logger.info("Finished reading JSON into memory.")
    env.logger.resetDebugLevels()
}


function read_json_dir() {
    // Returns
    //     dictionary of datasets, with the table name as each keys
    output = {}
    filepaths = get_json_paths()
    filepaths.forEach((filepath, _) => {
        let data = read_json_file(filepath)
        let table_name = path.basename(filepath).replace(".json", "")
        output[table_name] = data
    })
    return output
}


function get_json_paths() {
    // Returns
    //     list of paths for all JSON files in code/json
    return glob.sync( env.jsonPath + '*.json' )
}


function read_json_file(filepath) {
    // Parameters
    //    filepath - path of file to read
    // Returns
    //    JSON parsed contents of file
    let raw = fs.readFileSync(filepath)
    json = JSON.parse(raw)
    json.forEach((row, i) => {
        columns = Object.keys(row)
        columns.forEach((column, _) => {
            if (typeof row[column] == 'string') {
                json[i][column] = escape(row[column])
            } else {
                json[i][column] = row[column]
            }
        })
    })
    return json
  }


function get_table_structure(table) {
    output = {}
    iterator = 0
    column_types = get_column_types(table[iterator])
    while (Object.values(column_types).includes('skipped')) {
        // Retry type-check if null value was found during parsing
        iterator += 1
        column_types = get_column_types(table[iterator], column_types)
    }
    table.forEach((_, i) => {
        Object.keys(column_types).forEach((type, _) => {
            if (column_types[type].includes('string')){
                if (column_types[type] === 'string') {
                        column = 'string0'
                }
                length = column.replace('string', '')
                if (table[i][type] && (parseInt(length) < table[i][type].length)) {
                    length = table[i][type].length
                }
                column_types[type] = 'string' + length
            }
        })
    })
    return column_types
}

function get_column_types(row, graphql=false, retry=null) {
    // Returns 
    //    associative array of {column_name: column_type}
    let [types, table_keys] = check_retry(row, retry)
    table_keys.forEach((column, _) => {
        types[column] = get_column_type(column, row[column], graphql)
    })
    return types
}


function check_retry(row, retry) {
    if (retry) {
        table_keys = []
        Object.keys(retry).forEach((column, _) => {
            if (retry[column].includes('skipped')) {
                table_keys.push(column)
            }
        })
        types = retry
    } else {
        table_keys = Object.keys(row)
        types = {}
    }
    return [types, table_keys]
}

function get_column_type(key, value, graphql) {
    if (value === null) {
        return 'skipped'
    }
    if (!graphql) {
        return typeof value
    }
    if (check_for_substring(key, '_id') || key === 'id'){
        return 'ID'
    }
    return typeMap[typeof value]
}


function check_for_substring(string, substring) {
    // Returns
    //    Boolean, whether substring was found in string
    if (string.indexOf(substring) !== -1) {
      return true
    }
    return false
}


export_json_data()
