// relying on inverting key by value is dangerous while some keys share values (feat, modifier, descriptor)

const fs = require('fs')
const glob = require('glob')
const path = require('path');

const json_data = require('datasources/json_parser');
const env = require('env_vars');

class DefinitionsBuilder {
  
  models = {}

  constructor() {
    env.logger.setDebugLevels("definitions") // Set debugLevel!
    env.logger.info("Compiling typeDefs...")

    this.identify_relational_tables()
    let custom_defs = this.build_model_defs()
    let queryDefs = this.build_query_defs()
    this.typeDefs = `${queryDefs}\n\n${custom_defs}`

    env.logger.debug(1, "Models Defined:")
    env.logger.debug(1, this.models)
    env.logger.debug_precise(-616, this.typeDefs)

    env.logger.info("Finished compiling typeDefs.")
    env.logger.resetDebugLevels() // Reset debugLevel!
  }


  get_type_defs() {
    return this.typeDefs
  }


  identify_relational_tables() {
    env.logger.debug(1, "Identifying relational tables...")
    env.logger.debug(3, "Table Relationships:")

    this.set_associative_supported_tables()

    env.logger.debug(1, "Supported Tables:")
    env.logger.debug(1, env.supportedTables)
  }


  set_associative_supported_tables() {
    Object.keys(env.associativeTables).forEach((support_table) => {
      let association = env.associativeTables[support_table]
      association.supported_tables.forEach((table) => {
        env.supportedTables[table] = env.supportedTables[table] || new Set()
        env.supportedTables[table].add(support_table)
        env.logger.debug(3, "└─ ", table, "is supported by", support_table)
      })
    })
  }


  build_query_defs() {
    env.logger.debug(2, "Building root query definition...")
    this.indent = '  '
    let defs = 'type Query {\n'
    let tables = Object.keys(json_data.table_structures)
    tables.forEach((name) => {
      env.logger.debug(3, `Adding root definition entry for ${name}...`)
      let keys = this.set_def_keys(name)
      let model_name = getModelName(name)
      let def = `${name}${keys}: [${model_name}]`
      defs = `${defs}\n  ${def}\n`
    })
    return defs + '}'
  }

  set_def_keys(name) {
    let columns = json_data.table_structures[name]
    let column_names = Object.keys(columns)
    env.logger.debug(4, `  └─ Available columns to add as keys for ${name}: ${column_names}`)
    let output = '('
    column_names.forEach((column) => {
      let str = columns[column]
      if (['ID', 'String', 'Int'].includes(str)) {
        output = `${output}${column}: ${str} `
      } else if(str.includes('string')) {
        output = `${output}${column}: String `
      } else if (str.includes('_id')) {
        let name = str.replace('_id', 'id')
        let model = getModelName(name)
        let table = getTableByModel(model)
        output = `${output}${name}: ${table} `
      } else if (str.includes('id') || str.includes('number')) {
        output = `${output}${column}: Int `
      }
    })
    output = output + ')'
    if (output.length > 2) {
      env.logger.debug(4, `    └─ Created query keys ${output} for '${name}' definition.`)
      return output
    }
    return ''
  }

  build_model_defs() {
    env.logger.debug(1, "Building model definitions...")
    this.indent = ''
    let defs = ''
    Object.keys(json_data.table_structures).forEach((table) => {
      let model_name = getModelName(table)
      if(!defs.includes(`type ${model_name} {`)) {
        table = getTableByModel(model_name) // Don't let associative tables pre-write bad info
        let def = this.build_def(model_name, json_data.table_structures[table])
        defs = `${defs}\n${def}`
      }
    })
    return defs
  }


  build_def(name, data) {
    env.logger.debug(2, `Building ${name} definition...`)
    this.models[name] = []
    let def = `type ${name} {\n`
    let typeDef = this.append_types(def, data, name)
    return typeDef + `}\n`
  }


  append_types(def, columns, name) {
    let column_names = Object.keys(columns)
    column_names.forEach((column) => {
      let output = this.gql_type(column, columns[column], name)
      env.logger.debug(4, "Appending to", name, `'${output}'`)
      def = `${def}  ${output}\n`
    })
    def = this.check_relational_tables(name, def)
    return def
  }


  gql_type(column, type, parent) {
    if (column.includes('id'))
      return this.gql_id_type(column, parent)
    if (type.includes('string'))
      return `${column}: String`
    if (type.includes('number'))
      return `${column}: Int`
    return `${column}: ${type}`
  }


  gql_id_type(column, parent) {
    // Returns
    //    A string of 'key: value' based on what type of 'id' reference was found
    if (column.includes('_id')) {
      let name = column.replace('_id', '')
      
      if (name.includes('parent')) {
        // If a table has a 'parent_id' column, it is referencing its own table
        let parent_model = getModelName(parent)
        env.logger.debug(4, `└─ Setting ${column} to reference parent model: ${parent_model}`)
        return `parent: ${parent_model || parent}`
      }
      return `${name}: ${getModelName(name)}`
      // 
      // Key should be singularized, lowercase, and feature underscores between words
      // let obj_name = getModelName(parent) || ref
      // name = obj_name.replace(/([A-Z])/g, ' $1').trim().replace(' ', '_').toLowerCase()
      // return `${name}: ${parent}`
    }
    return `${column}: ID`
  }

  check_relational_tables(name, def) {
    // Add relational table as list of target models
    let table_name = getTableByModel(name)
    if (table_name in env.supportedTables) {
      let relational_sources = env.supportedTables[table_name]
      relational_sources.forEach((source) => {
        let resolver_name = getModelName(source)
        if (name != resolver_name && !env.associativeTables[source].direct) {
          // if direct=true, source model must directly reference associative table by id
          this.models[name].push(source)
          let output = `${source}: [${resolver_name}]`
          def = `${def}  ${output}\n`
        }
      })
    }
    return def
  }


}


function getModelName(name) {
  if (env.tableSingulars[name])
    return env.tableSingulars[name]
  if (env.associativeTables[name])
   return env.associativeTables[name].model_name
  return undefined
}


function getTableByModel(value) {
  output = Object.keys(env.tableSingulars).find(key => env.tableSingulars[key] === value);
  if(output) {
    env.logger.debug(4, `Found model by name '${value}' in table_singulars.js`)
  } else {
    output = Object.keys(env.associativeTables).find(key => env.associativeTables[key].model_name === value);
    if (output)
      env.logger.debug(4, `Found model by name '${value}' in associative_tables.js`) 
    else
      throw new env.DatasourceError(`Model ${value} not found in associative_tables.js or table_singulars.js`)
  }
  return output
}


defBuilder = new DefinitionsBuilder()

module.exports = {
  typeDefs: defBuilder.get_type_defs(),
  getTableByModel: getTableByModel,
  getModelName: getModelName,
}
