// relying on inverting key by value is dangerous while some keys share values (feat, modifier, descriptor)

const fs = require('fs')
const glob = require('glob')
const path = require('path');

const parser = require('database/parser');
const QueryDefinitionString = require('definitions/query_definition')
const ModelDefinitionString = require('definitions/model_definition')
const env = require('env_vars');
const helpers = require('helpers')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('definitions')


class DefinitionsBuilder {

  model_defs = {}

  constructor() {
    LOGGER.verbose("Compiling typeDefs...")

    this.identify_relational_tables()
    this.build_model_defs()
    let custom_defs = Object.values(this.model_defs).join('\n')

    let queryDefs = this.build_query_defs()
    this.typeDefs = `${queryDefs}\n\n${custom_defs}`

    LOGGER.silly(this.typeDefs)
    LOGGER.verbose("Finished compiling typeDefs.")
  }


  get_type_defs() {
    return this.typeDefs
  }


  identify_relational_tables() {
    LOGGER.verbose("Identifying relational tables...")

    this.set_associative_supports()

    LOGGER.debug({"Supported Tables Data": env.supportedTables})
  }


  set_associative_supports() {
    Object.keys(env.associativeTables).forEach((support_table) => {
      let association = env.associativeTables[support_table]
      if (typeof(association.supports) == 'string')
        this.add_support_entry(support_table, association.supports)
      else {
        association.supports.forEach((supported_table) => {
          this.add_support_entry(support_table, supported_table)
        })
      }
    })
  }

  add_support_entry(support_table, supported_table) {
    env.supportedTables[supported_table] = env.supportedTables[supported_table] || new Set()
    env.supportedTables[supported_table].add(support_table)
    LOGGER.debug(`${supported_table} is supported by ${support_table}`)
  }

  build_query_defs() {
    LOGGER.verbose("Building root query definition...")
    this.indent = '  '
    let defs = 'type Query {\n'
    let tables = Object.keys(parser.table_structures)
    tables.forEach((name) => {
      LOGGER.debug(`Adding root definition entry for ${name}...`)
      let defString = new QueryDefinitionString(name).output()
      defs = `${defs}\n  ${defString}\n`
    })
    return defs + '}'
  }


  build_model_defs() {
    LOGGER.verbose("Building model definitions...")
    this.indent = ''
    Object.keys(parser.table_structures).forEach((table) => {
      let model_name = helpers.getModelName(table)
      if(!Object.keys(this.model_defs).includes(model_name)) {
        let defString = new ModelDefinitionString(model_name).output()
        this.model_defs[model_name] = defString
      }
    })
  }

}


module.exports = DefinitionsBuilder
