const { Op } = require("sequelize");

const { getTableByModel, newConnection } = require('helpers')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('resolvers')

class RelationalResolver {
    constructor(table_name, supported_table_name) {
        const resolverMap = {
            ManyToOne: this.manyToOne,
            ManyToMany: this.manyToMany,
            OneToMany: this.oneToMany,
        }
        this.relationshipType = env.associativeTables[table_name].relationshipType
        LOGGER.verbose(`Creating ${this.relationshipType} resolver for ${table_name}`)
        return resolverMap[this.relationshipType] (
            table_name, supported_table_name
        )
    }

    manyToOne(table_name) {
        return (parent_data, _, __) => { // begin resolver method logic
            let id = parent_data.dataValues[`${table_name}_id`]
            LOGGER.debug(`Many to One Query to ${table_name} for ID: ${id}`)
            let conn = newConnection()
            return conn.get_by_id(table_name, id);
        }
    }

    manyToMany(table_name, supported_table_name) {
        LOGGER.info(`Created Many to Many Resolver to ${table_name}`)
        let id_param = `${supported_table_name}_id`
        return (parent_data, _, __) => { // begin resolver method logic
            let conn = newConnection()
            let query = {}

            // Create resolver logic for queries based on parent table's id
            let value = parent_data.dataValues.id
            LOGGER.debug(`Many to Many Query to ${table_name} for ${id_param}: ${value}`)
            if (!value) { return [] }

            query[id_param] = value
            let target_table = getTableByModel(env.associativeTables[table_name].model_name, LOGGER)

            return conn._run_complex_query(table_name, query).then(response => {
                let childResolver = new ChildResolver(response, target_table)
                return childResolver.resolve()
            })
        }
    }

    oneToMany(table_name, supported_table_name) {
        LOGGER.info(`Created One to Many Resolver to ${table_name}`)
        let id_param = `${supported_table_name}_id`
        return (parent_data, _, __) => { // begin resolver method logic
            LOGGER.debug(`One to Many Query to ${table_name} for ${id_param}`)
            if (parent_data) { // parent_data is result from parent model resolver
                let conn = newConnection()
                let query = {}

                // Create resolver logic for queries based on parent table's id
                let value = parent_data.dataValues.id
                if (!value) { return [] }
                query[id_param] = value

                return conn._run_complex_query(table_name, query)
            }
            let conn = newConnection()
            return conn.findAll(table_name);
        }
    }
}

class ChildResolver {
    constructor (data, joins_to) {
        this.table_name = joins_to
        this.setQuery(data, joins_to)
    }

    setQuery(data, joins_to) {
        let ids = []
        let target_id = joins_to + '_id'
        data.forEach((row) => {
            ids.push(row.dataValues[target_id])
        })
        this.query = {'id': { [Op.in]: ids } }
    }

    resolve() {
        let conn = newConnection()
        return conn._run_complex_query(this.table_name, this.query)
    }
}

module.exports = RelationalResolver
