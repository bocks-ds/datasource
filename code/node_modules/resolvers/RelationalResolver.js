const { getTableByModel, newConnection } = require('helpers')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('resolvers')

class RelationalResolver {
    constructor(table_name, supported_table_name) {
        const resolverMap = {
            ManyToOne: this.manyToOne,
            ManyToMany: this.manyToMany,
            OneToMany: this.oneToMany,
        }
        this.relationshipType = env.associativeTables[table_name].relationshipType
        LOGGER.verbose(`Creating ${this.relationshipType} resolver for ${table_name}`)
        return resolverMap[this.relationshipType] (
            table_name, supported_table_name
        )
    }

    manyToOne(table_name) {
        return (parent_data, _, __) => { // begin resolver method logic
            let id = parent_data.dataValues[`${table_name}_id`]
            LOGGER.debug(`Many to One Query to ${table_name} for ID: ${id}`)
            let conn = newConnection()
            return conn.get_by_id(table_name, id);
        }
    }

    manyToMany(table_name, supported_table_name) {
        LOGGER.info(`Created Many to Many Resolver to ${table_name}`)
        let id_param = `${supported_table_name}_id`
        return (parent_data, _, __) => { // begin resolver method logic
            LOGGER.debug(`Many to Many Query to ${table_name} for ${id_param}`)
            if (parent_data) { // parent_data is result from parent model resolver
                let conn = newConnection()
                let query = {}

                // Create resolver logic for queries based on parent table's id
                let value = parent_data.dataValues.id
                if (!value) { return [] }

                query[id_param] = value
        
                return conn._run_complex_query(table_name, query).then(response => {
                    // continue if current table is supported by another, otherwise return
                    LOGGER.silly(`Junction table found for ${table_name}: ${supported_table_name}`)
                    return join(response, supported_table_name)
                })
            }
            let conn = newConnection()
            return conn.findAll(table_name);
        }
    }

    oneToMany(table_name, supported_table_name) {
        LOGGER.info(`Created One to Many Resolver to ${table_name}`)
        let id_param = `${supported_table_name}_id`
        return (parent_data, _, __) => { // begin resolver method logic
            LOGGER.debug(`One to Many Query to ${table_name} for ${id_param}`)
            if (parent_data) { // parent_data is result from parent model resolver
                let conn = newConnection()
                let query = {}

                // Create resolver logic for queries based on parent table's id
                let value = parent_data.dataValues.id
                if (!value) { return [] }
                query[id_param] = value

                return conn._run_complex_query(table_name, query)
            }
            let conn = newConnection()
            return conn.findAll(table_name);
        }
    }
}

function join(data, joins_to) {
    let target_id = joins_to + '_id'
    let query = []
    data.forEach((row) => {
        query.push(row.dataValues[target_id])
    })
    return new RelationalResolver(joins_to, 'id', query)
}

module.exports = RelationalResolver