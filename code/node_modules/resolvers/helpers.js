const { Op } = require("sequelize");
const SqliteDatasource = require('database/sqlite')

function newConnection() {
    /*  Get a unique sequelize connection to prevent queries from clashing
        Returns
        -------
            SqliteDatasource
    */
    return new SqliteDatasource(env.databaseInstance)
}
    

function queryBySearchArgs(table_name, args) {
    /*  Run a sequelize query based on the provided arguments
        Returns
        -------
            output - result of SqliteDatasource._run_complex_query
    */
    let conn = newConnection()
    let terms = parseSearchTerms(args)
    string_search = {}
    number_queries = {}
    if (Object.keys(terms.string_like).length > 0) {
        string_search = conn.get_string_queries(terms.string_like)
    }
    if (Object.keys(terms.number).length > 0) {
        number_queries = {}
        Object.keys(terms.number).forEach((arg) => {
            number_queries[arg] = {[Op.and]: terms.number[arg]}
        })
    }
    query = {...terms.string_is, ...string_search, ...number_queries}
    output = conn._run_complex_query(table_name, query)
    return output
}
    
    
function parseSearchTerms(args) {
    /*  Transform args from user-input into a dict of search terms
        Returns
        -------
            terms - dict of the following:
                .string_is - dict of columns to be searched for exact results
                .string_like - dict of columns to be searched for similar results
                .number - fully prepared sequelize query dict (easier to do this all at once)
    */
    let terms = {string_is: {}, string_like: {}, number: {}}
    let op_map = {'_max': Op.lte , '_min': Op.gte, '_equals': Op.eq, 'id': Op.eq}

    Object.keys(args).forEach((arg) => {
        Object.keys(op_map).forEach((op_term) => {
            if (arg.includes(op_term)) {
                parsed_arg = arg.replace(op_term, '')
                search_term = parsed_arg.endsWith('_') ? parsed_arg.slice(0, -1) : parsed_arg
                terms.number[search_term] = terms.number[search_term] || {}
                terms.number[search_term][op_map[op_term]] = args[arg]
            }
        })
        if(arg.includes('_like')) {
            column = arg.replace('_like', '')
            terms.string_like[column] = args[arg]
        } else if (arg.includes('_is')) {
            column = arg.replace('_is', '')
            terms.string_is[column] = args[arg]            
        }
    })
    return terms
}

module.exports = {
    newConnection = newConnection,
    queryBySearchArgs = queryBySearchArgs,
}