const helpers = require('helpers')

class ManyRelationalResolver {
    constructor(resolvers, junction_table_name, model_name, supported_table) {
    /*  Add resolver for querying a junction table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
        let target_table = ''
        try {
            target_table = helpers.getTableByModel(model_name)
        } catch (error) {
            env.logger.error(`Junction Table: [${junction_table_name}] Supported Table: [${supported_table}] Message: ${error}`)
        }

        let target_id = `${target_table}_id`

        env.logger.debug(2, `Building many-to-many resolver from ${model_name} to ${target_table} via ${junction_table_name}`)

        resolvers[model_name][junction_table_name] = (parent_data, _, __) => { // begin resolver method logic
                if (parent_data) { // parent_data is result from parent model resolver
                    // Create resolver logic for queries based on parent table's id
                    return new RelationalResolver(junction_table_name, target_id, parent_data.dataValues.id)
                }
                let conn = newConnection()

                env.logger.debug(2, "Simple Query:", junction_table_name)

                return conn.findAll(junction_table_name);
        }
        return resolvers
    }
}


class DirectQueryResolver {
    constructor(resolvers, model_name, table_name, parent=false) {
    /*  Add resolver for directly querying a table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
        let resolver_name = parent ? "parent" : table_name

        env.logger.debug(3, `Creating direct resolver in ${model_name} to ${resolver_name}`)

        resolvers[model_name][resolver_name] = (parent_data, _, __) => { // begin resolver method logic
            let id = parent_data.dataValues[`${resolver_name}_id`]

            env.logger.debug(1, "Simple Query:", table_name)

            let conn = newConnection()
            return conn.get_by_id(table_name, id);
        }
        return resolvers
    }
}


class RelationalResolver {
    constructor(table_name, key, value) {
    /*  Create a new query entry for the provided resolver.
        Returns
        -------
            array - Data returned from query against table_name.
                    If junction table provided, recursively returns data from juntion target instead.
    */
        if (!value) { return [] }

        let query = {}
        query[key] = value
        let conn = newConnection()

        return conn._run_complex_query(table_name, query).then(response => {
            // continue if current table is supported by another, otherwise return
            if(table_name in env.associativeTables) {
                let support_table = env.associativeTables[table_name]
                if ('junction_target' in support_table) {
                    env.logger.debug(2, `Junction table found for ${table_name}: ${support_table.junction_target}`)
                    return this.join(response, support_table.junction_target)
                }
            }
            return response
        })
    }

    join(data, junction_target) {
        let target_id = junction_target + '_id'
        let query = []
        data.forEach((row) => {
            query.push(row.dataValues[target_id])
        })
        return new RelationalResolver(junction_target, 'id', query)
    }
}

exports.ManyRelationalResolver = ManyRelationalResolver
exports.DirectQueryResolver = DirectQueryResolver