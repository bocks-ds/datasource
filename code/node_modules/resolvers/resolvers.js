const { getTableByModel, newConnection } = require('helpers')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('resolvers')

class ManyToManyResolver {
    constructor(resolvers, junction_table_name, model_name, supported_table) {
        /*  Add resolver for querying a junction table
            Returns
            -------
                resolvers - Same as value from parameter, but with additional entry
        */
        let target_table = ''
        try {
            target_table = getTableByModel(model_name, LOGGER)
        } catch (error) {
            LOGGER.error(`Junction Table: [${junction_table_name}] Supported Table: [${supported_table}] Message: ${error}`)
        }

        let target_id = `${target_table}_id`

        LOGGER.verbose(`Building many-to-many resolver from ${model_name} to ${target_table} via ${junction_table_name}`)

        resolvers[model_name][junction_table_name] = (parent_data, _, __) => { // begin resolver method logic
                if (parent_data) { // parent_data is result from parent model resolver
                    // Create resolver logic for queries based on parent table's id
                    return new RelationalResolver(junction_table_name, target_id, parent_data.dataValues.id)
                }
                let conn = newConnection()

                LOGGER.verbose(`Many to Many Query to ${junction_table_name}`)

                return conn.findAll(junction_table_name);
        }
        return resolvers
    }
}


class ManyToOneResolver {
    constructor(resolvers, model_name, table_name, parent=false) {
        /*  Add resolver for directly querying a table
            Returns
            -------
                resolvers - Same as value from parameter, but with additional entry
        */
        let resolver_name = parent ? "parent" : table_name

        LOGGER.verbose(`Creating direct resolver in ${model_name} to ${resolver_name}`)

        resolvers[model_name][resolver_name] = (parent_data, _, __) => { // begin resolver method logic
            let id = parent_data.dataValues[`${resolver_name}_id`]

            LOGGER.verbose(`Many to One Query to ${resolver_name} for ID: ${id}`)

            let conn = newConnection()
            return conn.get_by_id(table_name, id);
        }
        return resolvers
    }
}


class RelationalResolver {
    constructor(table_name, key, value) {
        /*  Create a new query entry for the provided resolver.
            Returns
            -------
                array - Data returned from query against table_name.
                        If junction table provided, recursively returns data from juntion target instead.
        */
        if (!value) { return [] }

        let query = {}
        query[key] = value
        let conn = newConnection()

        return conn._run_complex_query(table_name, query).then(response => {
            // continue if current table is supported by another, otherwise return
            if(table_name in env.associativeTables) {
                let supportTable = env.associativeTables[table_name]
                if (supportTable.relationshipType == 'ManyToMany') {
                    joins_to = getTableByModel(supportTable.model_name, LOGGER)
                    LOGGER.debug(`Junction table found for ${table_name}: ${joins_to}`)
                    return this.join(response, joins_to)
                }
            }
            return response
        })
    }

    join(data, joins_to) {
        let target_id = joins_to + '_id'
        let query = []
        data.forEach((row) => {
            query.push(row.dataValues[target_id])
        })
        return new RelationalResolver(joins_to, 'id', query)
    }
}

exports.ManyToManyResolver = ManyToManyResolver
exports.ManyToOneResolver = ManyToOneResolver