const { Op } = require("sequelize");

const env = require('env_vars')
const json_data = require('database/json_parser');
const SqliteDatasource = require('database/sqlite')
const helpers = require('helpers')


class ResolversBuilder {

    constructor() {
        env.logger.setDebugLevels("resolvers")
        env.logger.info("Compiling resolvers...")

        let resolvers = {
            Query: this.create_query_resolvers()
        }

        resolvers = this.append_relational_resolvers(resolvers)

        env.logger.debug_precise(-616, resolvers) // Optionally print all resolvers
        env.logger.info("Finished compiling resolvers.")
        env.logger.resetDebugLevels()
        return resolvers
    }

    create_query_resolvers() {
    /*  Creates a query resolver for every structure created in json_data
        Returns
        -------
            query_resolvers - Base resolvers object, may be extended subsequently
    */
        let query_resolvers = {}
        let def_names = Object.keys(json_data.table_structures)
        def_names.forEach((def_name, _) => {

            env.logger.debug(0, "Building resolver for:", def_name)

            query_resolvers[def_name] = (_, args, __, ___) => {
                let conn = new_connection()
                if (args) {
                    env.logger.debug("Arguments found:", args)
                    return query_by_search_args(def_name, args)
                }

                env.logger.debug(0, "Simple Query:", def_name)

                return conn.findAll(def_name);
            }
        })
        return query_resolvers
    }


    append_relational_resolvers(resolvers) {
    /*  This attempts to add a resolver entry for every supporting table/model.
        Returns
        -------
            resolvers - Same as value from parameter, but with new entries for
                        all support tables (both one-to-many and many-to-many)
    */
        Object.keys(env.supportedTables).forEach((supported_table_name, _) => {
            // Create method within resolver for each support table
            env.supportedTables[supported_table_name].forEach((table_name, _) => {
                let model_name = env.tableSingulars[supported_table_name]

                resolvers[model_name] = resolvers[model_name] || {} // Creates dict if not existing
                if (env.associativeTables[table_name].direct)
                    resolvers = new DirectQueryResolver(resolvers, model_name, table_name)
                else if (table_name == supported_table_name)
                    resolvers = new DirectQueryResolver(resolvers, model_name, table_name, true)
                else
                    resolvers = new ManyRelationalResolver(resolvers, table_name, model_name, supported_table_name)
            })
        })
        return resolvers
    }

}


function query_by_search_args(table_name, args) {
/*  Run a sequelize query based on the provided arguments
    Returns
    -------
        output - result of SqliteDatasource._run_complex_query
*/
    let conn = new_connection()
    let terms = parse_search_terms(args)
    string_search = {}
    number_queries = {}
    if (Object.keys(terms.string_like).length > 0) {
        string_search = conn.get_string_queries(terms.string_like)
    }
    if (Object.keys(terms.number).length > 0) {
        number_queries = {}
        Object.keys(terms.number).forEach((arg) => {
            number_queries[arg] = {[Op.and]: terms.number[arg]}
        })
    }
    query = {...terms.string_is, ...string_search, ...number_queries}
    output = conn._run_complex_query(table_name, query)
    return output
}


function parse_search_terms(args) {
/*  Transform args from user-input into a dict of search terms
    Returns
    -------
        terms - dict of the following:
            .string_is - dict of columns to be searched for exact results
            .string_like - dict of columns to be searched for similar results
            .number - fully prepared sequelize query dict (easier to do this all at once)
*/
    let terms = {string_is: {}, string_like: {}, number: {}}
    let op_map = {'_max': Op.lte , '_min': Op.gte, '_equals': Op.eq}

    Object.keys(args).forEach((arg) => {
        Object.keys(op_map).forEach((term) => {
            if (arg.includes(term)) {
                column = arg.replace(term, '')
                terms.number[column] = terms.number[column] || {}
                terms.number[column][op_map[term]] = args[arg]
            }
        })
        if(arg.includes('_like')) {
            column = arg.replace('_like', '')
            terms.string_like[column] = args[arg]
        } else if (arg.includes('_is')) {
            column = arg.replace('_is', '')
            terms.string_is[column] = args[arg]            
        }
    })
    return terms
}


class ManyRelationalResolver {
    constructor(resolvers, junction_table_name, model_name, supported_table_name) {
    /*  Add resolver for querying a junction table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
        let target_table = helpers.getTableByModel(model_name)
        let target_id = `${target_table}_id`

        env.logger.debug(3, `Building many-to-many resolver from ${model_name} to ${target_table} via ${junction_table_name}`)

        resolvers[model_name][junction_table_name] = (parent_data, _, __) => { // begin resolver method logic
                if (parent_data) { // parent_data is result from parent model resolver
                    // Create resolver logic for queries based on parent table's id
                    return new RelationalResolver(junction_table_name, target_id, parent_data.dataValues.id)
                }
                let conn = new_connection()

                env.logger.debug(2, "Simple Query:", junction_table_name)

                return conn.findAll(junction_table_name);
        }
        return resolvers
    }
}

class DirectQueryResolver {
    constructor(resolvers, model_name, table_name, parent=false) {
    /*  Add resolver for directly querying a table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
        let resolver_name = parent ? "parent" : table_name

        env.logger.debug(3, `Creating direct resolver in ${model_name} to ${resolver_name}`)

        resolvers[model_name][resolver_name] = (parent_data, _, __) => { // begin resolver method logic
            let id = parent_data.dataValues[`${resolver_name}_id`]

            env.logger.debug(1, "Simple Query:", table_name)

            let conn = new_connection()
            return conn.get_by_id(table_name, id);
        }
        return resolvers
    }
}

class RelationalResolver {
    constructor(table_name, key, value) {
    /*  Create a new query entry for the provided resolver.
        Returns
        -------
            array - Data returned from query against table_name.
                    If junction table provided, recursively returns data from juntion target instead.
    */
        if (!value) { return [] }

        let query = {}
        query[key] = value
        let conn = new_connection()

        return conn._run_complex_query(table_name, query).then(response => {
            // continue if current table is supported by another, otherwise return
            if(table_name in env.associativeTables) {
                let support_table = env.associativeTables[table_name]
                if ('junction_target' in support_table) {
                    env.logger.debug(1, `Junction table found for ${table_name}: ${support_table.junction_target}`)
                    return this.join(response, support_table.junction_target)
                }
            }
            return response
        })
    }

    join(data, junction_target) {
        let target_id = junction_target + '_id'
        let query = []
        data.forEach((row) => {
            query.push(row.dataValues[target_id])
        })
        return new RelationalResolver(junction_target, 'id', query)
    }
}

function new_connection() {
/*  Get a unique sequelize connection to prevent queries from clashing
    Returns
    -------
        SqliteDatasource
*/
    return new SqliteDatasource(env.databaseInstance)
}

module.exports = ResolversBuilder
