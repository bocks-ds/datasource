const { Op } = require("sequelize");

const env = require('env_vars')
const json_data = require('database/json_parser');
const SqliteDatasource = require('database/sqlite')
const helpers = require('helpers')


class ResolversBuilder {

    constructor() {
        env.logger.setDebugLevels("resolvers")
        env.logger.info("Compiling resolvers...")

        let resolvers = {
            Query: this.create_query_resolvers()
        }

        resolvers = this.append_relational_resolvers(resolvers)

        env.logger.debug_precise(-616, resolvers) // Optionally print all resolvers
        env.logger.info("Finished compiling resolvers.")
        env.logger.resetDebugLevels()
        return resolvers
    }

    create_query_resolvers() {
    /*  Creates a query resolver for every structure created in json_data
        Returns
        -------
            query_resolvers - Base resolvers object, may be extended subsequently
    */
        let query_resolvers = {}
        let def_names = Object.keys(json_data.table_structures)
        def_names.forEach((def_name, _) => {

            env.logger.debug(2, "Building resolver for:", def_name)

            query_resolvers[def_name] = (_, args, __, ___) => {
                let conn = new_connection()
                if (args) {
                    return query_by_search_args(def_name, args)
                }

                env.logger.debug(1, "Simple Query:", def_name)

                return conn.findAll(def_name);
            }
        })
        return query_resolvers
    }


    append_relational_resolvers(resolvers) {
    /*  This attempts to add a resolver entry for every supporting table/model.
        Returns
        -------
            resolvers - Same as value from parameter, but with new entries for
                        all support tables (both one-to-many and many-to-many)
    */
        Object.keys(env.supportedTables).forEach((supported_table_name, _) => {
            // Create method within resolver for each support table
            env.supportedTables[supported_table_name].forEach((table_name, _) => {
                let model_name = env.tableSingulars[supported_table_name]

                env.logger.debug(3, `Building relational resolver method for ${model_name}: ${table_name}`)

                resolvers[model_name] = resolvers[model_name] || {} // Creates dict if not existing
                if (env.associativeTables[table_name].direct)
                    resolvers = direct_query(resolvers, model_name, table_name)
                else if (table_name == supported_table_name)
                    resolvers = direct_query(resolvers, model_name, table_name, true)
                else
                    resolvers = many_relational_query(resolvers, table_name, model_name, supported_table_name)
            })
        })
        return resolvers
    }

}


function query_by_search_args(table_name, args) {
/*  Run a sequelize query based on the provided arguments
    Returns
    -------
        output - result of SqliteDatasource._run_complex_query
*/
    let conn = new_connection()
    let terms = parse_search_terms(args)
    string_search = {}
    number_queries = {}
    if (Object.keys(terms.string_like).length > 0) {
        string_search = conn.get_string_queries(terms.string_like)
    }
    if (Object.keys(terms.number).length > 0) {
        number_queries = {}
        Object.keys(terms.number).forEach((arg) => {
            number_queries[arg] = {[Op.and]: terms.number[arg]}
        })
    }
    query = {...terms.string_is, ...string_search, ...number_queries}
    output = conn._run_complex_query(table_name, query)
    return output
}


function parse_search_terms(args) {
/*  Transform args from user-input into a dict of search terms
    Returns
    -------
        terms - dict of the following:
            .string_is - dict of columns to be searched for exact results
            .string_like - dict of columns to be searched for similar results
            .number - fully prepared sequelize query dict (easier to do this all at once)
*/
    let terms = {string_is: {}, string_like: {}, number: {}}
    let op_map = {'_max': Op.lte , '_min': Op.gte, '_equals': Op.eq}

    Object.keys(args).forEach((arg) => {
        Object.keys(op_map).forEach((term) => {
            if (arg.includes(term)) {
                column = arg.replace(term, '')
                terms.number[column] = terms.number[column] || {}
                terms.number[column][op_map[term]] = args[arg]
            }
        })
        if(arg.includes('_like')) {
            column = arg.replace('_like', '')
            terms.string_like[column] = args[arg]
        } else if (arg.includes('_is')) {
            column = arg.replace('_is', '')
            terms.string_is[column] = args[arg]            
        }
    })
    return terms
}


function many_relational_query(resolvers, table_name, model_name, supported_table_name) {
/*  Add resolver for querying a junction table
    Returns
    -------
        resolvers - Same as value from parameter, but with additional entry
*/
   resolvers[model_name][table_name] = (parent_data, _, __) => { // begin resolver method logic
        if (parent_data) { // parent_data is result from parent model resolver
            // Create resolver logic for queries based on parent table's id
            let origin_table = helpers.getTableByModel(model_name)
            let origin_id_name = `${origin_table}_id`

            env.logger.debug(2, `Supporting ${supported_table_name} with data from ${table_name}`)

            // Fetch target results using current associative table
            return relational_query(table_name, origin_id_name, parent_data.dataValues.id)
        }
        let conn = new_connection()

        env.logger.debug(2, "Simple Query:", table_name)

        return conn.findAll(table_name);
    }
    return resolvers
}


function direct_query(resolvers, model_name, table_name, parent=false) {
/*  Add resolver for directly querying a table
    Returns
    -------
        resolvers - Same as value from parameter, but with additional entry
*/
    resolver_name = parent ? "parent" : table_name

    resolvers[model_name][resolver_name] = (parent_data, _, __) => { // begin resolver method logic
        id = parent_data.dataValues[`${resolver_name}_id`]

        env.logger.debug(1, "Simple Query:", table_name)

        let conn = new_connection()
        return conn.get_by_id(table_name, id);
    }
    return resolvers
}


function relational_query(table_name, key, value) {
/*  Create a new query entry for the provided reolver.
    Returns
    -------
        array - Data returned from query against table_name.
                If junction table provided, recursively returns data from juntion target instead.
*/
    if (!value) { return [] }

    let query = {}
    query[key] = value
    let conn = new_connection()

    return conn._run_complex_query(table_name, query).then(response => {
        // continue if current table is supported by another, otherwise return
        if(table_name in env.associativeTables) {
            support_table = env.associativeTables[table_name]
            if ('junction_target' in support_table) {
                target_table = support_table.junction_target

                env.logger.debug(2, `Junction table found for ${table_name}: ${target_table}`)

                target_id = support_table.junction_target + '_id'
                subquery_value = []
                response.forEach((row) => {
                    subquery_value.push(row.dataValues[target_id])
                })
                return relational_query(target_table, 'id', subquery_value, table_name)
            }
        }
        return response
    })
}


function new_connection() {
/*  Get a unique sequelize connection to prevent queries from clashing
    Returns
    -------
        SqliteDatasource
*/
    return new SqliteDatasource(env.databaseInstance)
}

module.exports = ResolversBuilder
