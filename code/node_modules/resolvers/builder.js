const env = require('env_vars')
const json_data = require('database/json_parser');
const connection = require('database/sqlite')
const helpers = require('helpers')


class ResolversBuilder {

    constructor() {
        env.logger.setDebugLevels("resolvers")
        env.logger.info("Compiling resolvers...")

        let resolvers = {
            Query: this.create_query_resolvers()
        }

        resolvers = this.append_relational_resolvers(resolvers)

        env.logger.debug_precise(-616, resolvers) // Optionally print all resolvers
        env.logger.info("Finished compiling resolvers.")
        env.logger.resetDebugLevels()
        return resolvers
    }

    create_query_resolvers() {
        /* Creates a query resolver for every structure created in json_data
        Returns
        -------
            query_resolvers - Base resolvers object, may be extended subsequently
        */
        let query_resolvers = {}
        let def_names = Object.keys(json_data.table_structures)
        def_names.forEach((def_name, _) => {
            env.logger.debug(2, "Building resolver for:", def_name)
            query_resolvers[def_name] = (_, args, __, ___) => {
                let conn = new_connection()
                if (args) {
                    return conn._run_complex_query(def_name, args)
                }
                env.logger.debug(1, "Simple Query:", def_name)
                return conn.findAll(def_name);
            }
        })
        return query_resolvers
    }


    append_relational_resolvers(resolvers) {
    /*  This attempts to add a resolver entry for every supporting table/model.
        Returns
        -------
            resolvers - Same as value from parameter, but new entries for
                        all support tables (both one-to-many and many-to-many)
    */
        Object.keys(env.supportedTables).forEach((supported_table_name, _) => {
            // Create method within resolver for each support table
            env.supportedTables[supported_table_name].forEach((table_name, _) => {
                let model_name = env.tableSingulars[supported_table_name]
                env.logger.debug(3, `Building relational resolver method for ${model_name}: ${table_name}`)
                resolvers[model_name] = resolvers[model_name] || {} // Creates dict if not existing
                if (env.associativeTables[table_name].direct)
                    resolvers = direct_query(resolvers, model_name, table_name)
                else if (table_name == supported_table_name)
                    resolvers = direct_query(resolvers, model_name, table_name, true)
                else
                    resolvers = many_relational_query(resolvers, table_name, model_name, supported_table_name)
            })
        })
        return resolvers
    }

}


function many_relational_query(resolvers, table_name, model_name, supported_table_name) {
    /*  Add resolver for querying a junction table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
   resolvers[model_name][table_name] = (parent_data, _, __) => { // begin resolver method logic
        if (parent_data) { // parent_data is result from parent model resolver
            // Create resolver logic for queries based on parent table's id
            let origin_table = helpers.getTableByModel(model_name)
            let origin_id_name = `${origin_table}_id`
            // Fetch target results using current associative table
            env.logger.debug(2, `Supporting ${supported_table_name} with data from ${table_name}`)
            return relational_query(table_name, origin_id_name, parent_data.dataValues.id)
        }
        let conn = new_connection()
        env.logger.debug(2, "Simple Query:", table_name)
        return conn.findAll(table_name);
    }
    return resolvers
}


function direct_query(resolvers, model_name, table_name, parent=false) {
    /*  Add resolver for directly querying a table
        Returns
        -------
            resolvers - Same as value from parameter, but with additional entry
    */
    resolver_name = parent ? "parent" : table_name

    resolvers[model_name][resolver_name] = (parent_data, _, __) => { // begin resolver method logic
        id = parent_data.dataValues[`${resolver_name}_id`]
        env.logger.debug(2, "Simple Query:", table_name)
        let conn = new_connection()
        return conn.get_by_id(table_name, id);
    }
    return resolvers
}


function relational_query(table_name, key, value) {
    /*  Create a new query entry for the provided reolver.
        Returns
        -------
            array - Data returned from query against table_name.
                    If junction table provided, recursively returns data from juntion target instead.
    */
    if (!value) { return [] }

    let query = {}
    query[key] = value
    let conn = new_connection()

    return conn._run_complex_query(table_name, query).then(response => {
        // continue if current table is supported by another, otherwise return
        if(table_name in env.associativeTables) {
            support_table = env.associativeTables[table_name]
            if ('junction_target' in support_table) {
                target_table = support_table.junction_target
                env.logger.debug(2, `Junction table found for ${table_name}: ${target_table}`)
                // get all target ids
                target_id = support_table.junction_target + '_id'
                subquery_value = []
                response.forEach((row) => {
                    subquery_value.push(row.dataValues[target_id])
                })
                return relational_query(target_table, 'id', subquery_value, table_name)
            }
        }
        return response
    })
}


function new_connection() {
    return new connection(env.databaseInstance)
}

module.exports = ResolversBuilder
