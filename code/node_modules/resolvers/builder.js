const env = require('env_vars')
const parser = require('database/parser');
const { newConnection, queryBySearchArgs, newUUID, isEmptyObject } = require('helpers')
const { ManyToManyResolver, ManyToOneResolver } = require('resolvers/resolvers.js')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('resolvers')

class ResolversBuilder {

    constructor() {
        LOGGER.info("Compiling resolvers...")

        let resolvers = {
            Query: this.create_query_resolvers()
        }

        resolvers = this.append_relational_resolvers(resolvers)

        LOGGER.silly("Resolvers Created:", Object.keys(resolvers).join(' ')) // Optionally print all resolvers
        LOGGER.info("Finished compiling resolvers.")
        return resolvers
    }

    create_query_resolvers() {
    /*  Creates a query resolver for every structure created in parser
        Returns
        -------
            query_resolvers - Base resolvers object, may be extended subsequently
    */
        let query_resolvers = {}
        let def_names = Object.keys(parser.table_structures)
        def_names.forEach((definition, _) => {

            LOGGER.debug(`Building resolver for: ${definition}`)

            query_resolvers[definition] = (_, args, __, ___) => {
                let log_id = newUUID()
                let conn = newConnection()
                if (!isEmptyObject(args)) {
                    LOGGER.verbose(`[${log_id}] Arguments found: ${JSON.stringify(args)}`)
                    return queryBySearchArgs(definition, args, log_id)
                }
                return conn.findAll(definition, log_id);
            }
        })
        return query_resolvers
    }


    append_relational_resolvers(resolvers) {
    /*  This attempts to add a resolver entry for every supporting table/model.
        Returns
        -------
            resolvers - Same as value from parameter, but with new entries for
                        all support tables (both one-to-many and many-to-many)
    */
        Object.keys(env.supportedTables).forEach((supported_table_name, _) => {
            // Create method within resolver for each support table
            env.supportedTables[supported_table_name].forEach((table_name, _) => {
                let model_name = env.tableSingulars[supported_table_name]
                let log_id = newUUID()

                resolvers[model_name] = resolvers[model_name] || {} // Creates dict if not existing
                if (env.associativeTables[table_name].relationshipType == 'ManyToOne') {
                    resolvers = new ManyToOneResolver(log_id, resolvers, model_name, table_name)
                }
                else if (table_name == supported_table_name)
                    resolvers = new ManyToOneResolver(log_id, resolvers, model_name, table_name, true)
                else
                    resolvers = new ManyToManyResolver(log_id, resolvers, table_name, model_name, supported_table_name)
            })
        })
        return resolvers
    }
}


module.exports = ResolversBuilder
