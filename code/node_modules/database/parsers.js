const fs = require('fs')
const glob = require('glob')
const path = require('path');

const Papa = require('papaparse')

const env = require('env_vars')

const typeMap = {'string': 'String', 'number': 'Int'}

class ParserABC {
    constructor() {
        env.logger.setDebugLevels("database")
        env.logger.debug(1, "Loading data from", this.constructor.name, "...")

        this.table_names = {}
        this.set_data()

        env.logger.debug(1, "Finished loading data.")
        env.logger.resetDebugLevels()
    }

    set_data() {
        // Returns
        //     dictionary of datasets, with the table name as each keys
        let output = {}
        let filepaths = this.getFilepaths()
        filepaths.forEach((filepath, _) => {
            let data = this.read_file(filepath)
            let table_name = path.basename(filepath).split('.')[0]
            let usable_tables = [...Object.keys(env.tableSingulars), ...Object.keys(env.associativeTables)]
            if (usable_tables.includes(table_name)) {
                output[table_name] = data
            }
        })
        this.data = output
        this.table_names = Object.keys(output)
        this.set_table_structures()
    }

    getFilepaths() {
        // Returns
        //     list of paths for all CSV files in code/json
        let dataPath = path.resolve(__dirname, `../../app/${env.dataType}`)
        env.logger.debug(2, "Reading file group", `${dataPath}/*.${env.dataType}`, "...")
        return glob.sync(`${dataPath}/*.${env.dataType}`)
    }

    read_file(filepath) {
        // Parameters
        //    filepath - path of file to read
        // Returns
        //    Parsed contents of file
        let raw = fs.readFileSync(filepath, 'utf8');
        let data = this.parseContents(raw)
        data.forEach((row, i) => {
            let columns = Object.keys(row)
            columns.forEach((column, _) => {
                if (typeof row[column] == 'string') {
                    data[i][column] = escape(row[column])
                } else {
                    data[i][column] = row[column]
                }
            })
        })
        env.logger.debug(3, "Finished reading file:", filepath)
        return data
      }

    parseContents(data) { 
        // Abstract method to parse file contents
        return data
    }

    set_table_structures() {
        let _table_structures = {}
        this.table_names.forEach((table_name, _) => {
            env.logger.debug(2, "Identifying table structure:", table_name)
            let structure = this.get_table_structure(this.data[table_name])
            _table_structures[table_name] = structure
        })
        this.table_structures = _table_structures
    }

    get_table_structure(table) {
        let iterator = 0
        let column_types = this.get_column_types(table[iterator])
        while (Object.values(column_types).includes('skipped')) {
            // Retry type-check if null value was found during parsing
            iterator += 1
            if (table[iterator]) { 
                column_types = this.get_column_types(table[iterator], column_types)
            } else {
                Object.keys(column_types).forEach(key => {
                    if (column_types[key] === 'skipped') {
                        delete column_types[key]
                    }
                })
            }
        }
        column_types = this.get_string_column_lengths(table, column_types)
        return column_types
    }

    get_column_types(row, retry=false) {
        // Returns 
        //    associative array of {column_name: column_type}
        let [types, table_keys] = this.check_retry(row, retry)
        table_keys.forEach((column, _) => {
            types[column] = this.get_column_type(column, row[column])
            if (types[column] != 'skipped') {
                env.logger.debug(4, "Identified column", column, "as", types[column])
            }
        })
        return types
    }

    get_string_column_lengths(table, column_types) {
        let table_string_columns = {}
        table.forEach((_, i) => {
            Object.keys(column_types).forEach((column) => {
                if (column=='__parsed_extra') {
                    throw new env.DatasourceError(`Extra columns found; delimiter may be incorrect. \nTable: ${table}\nExtra Data: "${table[i][column]}"\n`)
                }
                if (column_types[column].includes('tring')){
                    if (!table_string_columns[column])
                        table_string_columns[column] = 0
                    let previous_length = table_string_columns[column]
                    let content = table[i][column]
                    // if row/column has content & counter is less than content length
                    if (content && (previous_length < content.length)) {
                        table_string_columns[column] = content.length
                    }
                }
            })
        })
        Object.keys(table_string_columns).forEach((column) => {
            column_types[column] = 'string' + table_string_columns[column]
        })
        return column_types
    }

    check_retry(row, retry) {
        let table_keys = []
        let types = {}
        if (retry) {
            Object.keys(retry).forEach((column, _) => {
                if (retry[column].includes('skipped')) {
                    table_keys.push(column)
                }
            })
            types = retry
        } else {
            table_keys = Object.keys(row)
        }
        return [types, table_keys]
    }

    get_column_type(key, value) {
        if (key === 'id' || this.check_for_substring(key, '_id')){
            return 'ID'
        }
        if (!value) {
            return 'skipped'
        }
        return typeMap[typeof value]
    }

    check_for_substring(string, substring) {
        // Returns
        //    Boolean, whether substring was found in string
        if (string.indexOf(substring) !== -1) {
          return true
        }
        return false
    }
}

class CsvParser extends ParserABC {

    parseContents(csv_string) {
        let data = Papa.parse(csv_string, {header: true, dynamicTyping: true, delimiter: env.delimiter}).data
        return data
    }
}

class JsonParser extends ParserABC {
    parseContents(data) {
        return JSON.parse(data)
    }
}

exports.CsvParser = CsvParser
exports.JsonParser = JsonParser