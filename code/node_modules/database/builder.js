const { Sequelize, DataTypes } = require('sequelize');

const env = require('env_vars')
const parser = require('database/parser')
const {newLogger} = require('winston_logger')


const LOGGER = newLogger('database')


class SqliteDatabase {

    constructor() {
        this.db = new Sequelize('sqlite::memory:', {logging:false})
        this.models = {}
    }

    async initialize() {
        LOGGER.info("Initializing Database...")
        // Stagger creates & inserts to limit time-consuming syncs
        await this.create_tables()
        await this.insert_tables()

        while(!identical_shallow_arrays(parser.table_names, Object.keys(this.models))) {
            LOGGER.info("Waiting for Database Initialization...")
        }
        LOGGER.info("Database Initialization Complete.")
        LOGGER.verbose(`Sequelize Models: ${Object.keys(this.models).join(", ")}`)
        env.databaseInstance = this

        return true
    }


    async create_tables() {
        await parser.table_names.forEach((name, i) => {
            let table_structure = parser.table_structures[name]
            this.create_table(name, table_structure)
            this.models[name] = this.db.model(name)
        })
        await this.db.sync()

    }

    async insert_tables() {
        await parser.table_names.forEach((name, i) => {
            let data = this.decode_json(parser.data[name])
            this.insert_table(name, data)
        })
        await this.db.sync()
    }

    decode_json(json) {
        json.forEach((row, index) => {
            let columns = Object.keys(row)
            columns.forEach((column, i) => {
                if (typeof row[column] == 'string') {
                    json[index][column] = unescape(row[column])
                } else {
                    json[index][column] = row[column]
                }
            })
        })
        return json
    }

    async test_connection() {
        try {
            await this.db.authenticate();
            LOGGER.info('Connection has been established successfully.');
        } catch (error) {
            LOGGER.error('Unable to connect to the database:', error);
        }
    }


    create_table(name, data) {
        let definition = this.build_table_definition(data, name)
        LOGGER.debug(`Creating Table: ${name}`)
        try {
            this.db.define(name, definition)
        } catch (error) {
            LOGGER.error(`Failed to create table: ${name}`)
            LOGGER.verbose(error)
        }
        return true
    }


    build_table_definition(data) {
        let output = {}
        let keys = Object.keys(data)
        LOGGER.debug(`Table columns: ${keys.join(', ')}`)
        keys.forEach((column, i) => {
            if (column == 'id') {
                output['id'] = this.id_structure()
            } else {
                output[column] = {
                    type: this.column_type(data[column]),
                }
            }
        })
        return output
    }


    id_structure() {
        return {
            type: new DataTypes.INTEGER,
            allowNull: false,
            primaryKey: true,
        }
    }


    column_type(column) {
        if (column == 'number') {
            return new DataTypes.INTEGER()
        }
        let length = column.replace('string', '')
        return DataTypes.STRING(parseInt(length))
    }


    insert_table(name, data) {
        let model = this.db.model(name)
        model.bulkCreate(data).then(_ => {
            LOGGER.debug(`Inserted data to table '${name}'`)
            return true
        }, reason => {
            LOGGER.error(`Failed to insert data to ${name}.`)
            LOGGER.verbose('Please verify your datafile is properly formatted and all ID values are unique')
        })
    }
}


function identical_shallow_arrays(arr1, arr2) {
    if ( JSON.stringify(arr1) == JSON.stringify(arr2) ) {
        return true
    }
    return false
}


database = new SqliteDatabase()

module.exports = database