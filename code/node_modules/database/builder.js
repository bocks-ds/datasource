const { Sequelize, DataTypes } = require('sequelize');

const env = require('env_vars')
const json_data = require('database/json_parser')


class SqliteDatabase {

    constructor() {
        env.logger.setDebugLevels("database") // If subDebugLevel is found
        this.db = new Sequelize('sqlite::memory:', {logging:false})
        this.models = {}
        env.logger.resetDebugLevels() // Reset in case debugLevel was modified
    }

    async initialize() {
        env.logger.setDebugLevels("database")
        env.logger.info("Initializing Database...")
        // Stagger creates & inserts to limit time-consuming syncs
        await this.create_tables()
        await this.insert_tables()

        while(!identical_shallow_arrays(json_data.table_names, Object.keys(this.models))) {
            env.logger.debug(1, "Waiting for Database Initialization...")
        }
        env.logger.info("Database Initialization Complete.")
        env.logger.debug(4, "Sequelize Models:","\n----------\n",this.models,"\n----------\n")
        env.databaseInstance = this

        env.logger.resetDebugLevels()
        return true
    }


    async create_tables() {
        await json_data.table_names.forEach((name, i) => {
            let table_structure = json_data.table_structures[name]
            this.create_table(name, table_structure)
            this.models[name] = this.db.model(name)
        })
        await this.db.sync() 

    }

    async insert_tables() {
        await json_data.table_names.forEach((name, i) => {
            let data = this.decode_json(json_data.data[name])
            this.insert_table(name, data)
        })
        await this.db.sync()
    }

    decode_json(json) {
        json.forEach((row, index) => {
            let columns = Object.keys(row)
            columns.forEach((column, i) => {
                if (typeof row[column] == 'string') {
                    json[index][column] = unescape(row[column])
                } else {
                    json[index][column] = row[column]
                }
            })
        })
        return json
    }

    async test_connection() {
        try {
            await this.db.authenticate();
            console.debug('Connection has been established successfully.');
        } catch (error) {
            console.error('Unable to connect to the database:', error);
        }
    }


    create_table(name, data) {
        let definition = this.build_table_definition(data, name)
        try {
            this.db.define(name, definition)
            env.logger.debug(3, "Created Table:", name)
        } catch (error) {
            console.error("Failed to create:", name)
            env.logger.debug(2, error)
        }
        return true
    }


    build_table_definition(data, name) {
        let output = {}
        let keys = Object.keys(data)
        keys.forEach((column, i) => {
            if (column == 'id') {
                output['id'] = this.id_structure()
            } else {
                output[column] = {
                    type: this.column_type(data[column]),
                }
            }
        })
        return output
    }


    id_structure() {
        return {
            type: new DataTypes.INTEGER,
            allowNull: false,
            primaryKey: true,
        }
    }


    column_type(column) {
        if (column == 'number') {
            return new DataTypes.INTEGER()
        }
        let length = column.replace('string', '')
        return DataTypes.STRING(parseInt(length))
    }


    insert_table(name, data) {
        let model = this.db.model(name)
        model.bulkCreate(data).then(response => {
            env.logger.debug(2, "Inserted data:", name)
            return true
        }, reason => {
            console.error(name, "Failed to insert data.")
            env.logger.debug(3, reason)
        })
    }
}


function identical_shallow_arrays(arr1, arr2) {
    if ( JSON.stringify(arr1) == JSON.stringify(arr2) ) {
        return true
    }
    return false
}


database = new SqliteDatabase()

module.exports = database